---
layout: post
title: Java项目与数据库解耦
date: 2025-01-30 00:22
author: admin
comments: true
categories: [Java]
tags: [Java, JPA, ORM]
---


在Java项目中与数据库SQL解耦能增强代码的可维护性、可移植性和可测试性，以下是几种常见的实现方式及针对某Java项目的数据库SQL解耦的推荐方案。


<!-- more -->


## 常用数据库SQL解耦技术

常用数据库SQL解耦技术包括 Hibernate、Spring Data JPA、MyBatis等。其中， Hibernate、Spring Data JPA是真正完全的解耦技术， MyBatis 只是半解耦技术。

### Hibernate 优势

#### 1. 提高开发效率
- **减少重复代码**：Hibernate 提供了对象与数据库表之间的映射机制，使得开发者可以使用面向对象的方式操作数据库，无需编写大量的 SQL 语句。例如，开发者只需定义好 Java 对象及其属性，Hibernate 就能自动将对象的操作转换为相应的 SQL 操作，大大减少了数据访问层的代码量。
- **快速开发**：在开发过程中，使用 Hibernate 可以快速搭建起数据持久层，尤其对于一些简单的增删改查操作，开发速度会明显加快。比如在一个小型的 Web 应用中，开发者可以在短时间内完成数据库的基本操作功能。

#### 2. 数据库无关性
- **支持多种数据库**：Hibernate 可以与多种不同的数据库进行交互，如 MySQL、Oracle、SQL Server 等。开发者在开发过程中可以使用统一的 Java 代码进行数据库操作，而无需针对不同的数据库编写不同的 SQL 语句。当需要更换数据库时，只需要修改 Hibernate 的配置文件即可，提高了系统的可移植性。
- **屏蔽数据库差异**：不同的数据库在 SQL 语法和特性上可能存在一些差异，Hibernate 会自动处理这些差异，使得开发者无需关注这些细节。例如，在处理日期和时间类型时，不同数据库的处理方式可能不同，Hibernate 会将这些差异进行统一封装。

#### 3. 事务管理方便
- **集成事务管理**：Hibernate 与 Java 的事务管理机制集成良好，支持声明式事务和编程式事务。开发者可以很方便地管理数据库事务，确保数据的一致性和完整性。例如，在一个业务逻辑中涉及多个数据库操作，开发者可以将这些操作放在一个事务中，若其中一个操作失败，整个事务会回滚，保证数据的正确性。

#### 4. 缓存机制
- **一级缓存和二级缓存**：Hibernate 提供了一级缓存（Session 级别的缓存）和二级缓存（SessionFactory 级别的缓存）机制。一级缓存可以在同一个 Session 中缓存查询结果，避免重复查询数据库；二级缓存可以在多个 Session 之间共享缓存数据，减少数据库的访问次数，提高系统的性能。例如，在一个高并发的系统中，对于一些经常访问的数据，可以使用二级缓存来提高系统的响应速度。

### Hibernate 劣势
#### 1. 性能问题
- **生成复杂 SQL**：在处理复杂查询时，Hibernate 自动生成的 SQL 语句可能会比较复杂，执行效率较低。例如，在进行多表关联查询时，Hibernate 可能会生成一些不必要的子查询或连接，导致数据库的性能下降。
- **缓存管理复杂**：虽然 Hibernate 的缓存机制可以提高性能，但缓存的管理和维护比较复杂。如果缓存配置不当，可能会导致数据不一致的问题。例如，当数据发生更新时，如果没有及时更新缓存，就会导致查询到的数据不是最新的。

#### 2. 学习成本较高
- **概念和配置复杂**：Hibernate 有很多复杂的概念和配置选项，如映射文件、查询语言（HQL）、缓存配置等。对于初学者来说，需要花费较多的时间来学习和掌握这些知识。例如，理解 Hibernate 的延迟加载、级联操作等概念需要一定的时间和实践经验。

#### 3. 对 SQL 控制能力有限
- **难以进行精细化优化**：在一些对 SQL 性能要求极高的场景下，Hibernate 的自动生成 SQL 机制可能无法满足需求。开发者很难对生成的 SQL 语句进行精细化的优化，因为 Hibernate 会将对象操作转换为 SQL 语句，开发者无法直接控制 SQL 的执行过程。例如，在处理一些复杂的业务逻辑时，可能需要编写高效的 SQL 语句来提高性能，但使用 Hibernate 可能无法实现。

#### 4. 调试困难
- **错误信息不直观**：当 Hibernate 出现问题时，其抛出的错误信息可能不够直观，难以定位问题的根源。例如，由于 Hibernate 自动生成 SQL 语句，当出现 SQL 执行错误时，错误信息可能只显示生成的 SQL 语句和数据库的错误信息，开发者很难直接从这些信息中判断出是 Hibernate 配置问题还是业务逻辑问题。 

### Spring Data JPA 优势
#### 1. 简化数据访问层开发
- **减少样板代码**：Spring Data JPA 基于 JPA 标准，通过定义简单的接口，就能自动实现基本的增删改查（CRUD）操作，无需开发者编写大量重复的 SQL 语句和数据访问逻辑代码。例如，只需定义一个继承自 `JpaRepository` 的接口，就能直接使用 `save`、`findAll`、`findById` 等方法。
```java
import org.springframework.data.jpa.repository.JpaRepository;
import com.example.entity.User;

public interface UserRepository extends JpaRepository<User, Long> {
    // 无需编写方法实现，即可使用基本的 CRUD 操作
}
```
- **自动方法解析**：Spring Data JPA 可以根据方法名自动解析并生成对应的查询语句。比如，定义一个名为 `findByUsername` 的方法，Spring Data JPA 会自动根据 `username` 字段进行查询。
```java
import org.springframework.data.jpa.repository.JpaRepository;
import com.example.entity.User;

public interface UserRepository extends JpaRepository<User, Long> {
    User findByUsername(String username);
}
```

#### 2. 与 Spring 框架无缝集成
- **利用 Spring 特性**：由于是 Spring 框架的一部分，Spring Data JPA 可以充分利用 Spring 的依赖注入、事务管理等特性。开发者可以轻松地将数据访问层的组件注入到服务层，并且通过 Spring 的声明式事务管理来管理数据库事务。
- **简化配置**：借助 Spring Boot 的自动配置功能，Spring Data JPA 的配置变得非常简单。开发者只需要添加相应的依赖，Spring Boot 就能自动配置数据源、JPA 实体管理器等，减少了配置文件的编写量。

#### 3. 支持复杂查询
- **自定义查询**：除了自动生成的查询方法，Spring Data JPA 还支持使用 `@Query` 注解编写自定义的 JPQL（Java Persistence Query Language）或 SQL 查询。这使得开发者能够处理复杂的查询需求，同时保持代码的简洁性。
```java
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import com.example.entity.User;

public interface UserRepository extends JpaRepository<User, Long> {
    @Query("SELECT u FROM User u WHERE u.age > :age")
    List<User> findUsersByAgeGreaterThan(int age);
}
```
- **分页和排序**：Spring Data JPA 提供了对分页和排序的支持，开发者可以方便地实现数据的分页查询和排序功能，无需手动编写复杂的 SQL 语句。

#### 4. 提高开发效率和可维护性
- **标准化开发**：Spring Data JPA 遵循 JPA 标准，使得不同数据库之间的切换更加容易，提高了代码的可移植性。同时，它提供了统一的接口和方法命名规范，使得代码结构更加清晰，易于维护和理解。

### Spring Data JPA 劣势
#### 1. 性能问题
- **自动生成 SQL 不够优化**：在某些复杂查询场景下，Spring Data JPA 自动生成的 SQL 语句可能不够优化，导致性能下降。例如，在处理多表关联查询时，可能会生成一些不必要的子查询或连接，影响查询效率。
- **缓存管理复杂**：虽然 JPA 提供了缓存机制，但 Spring Data JPA 的缓存管理相对复杂。如果配置不当，可能会导致数据不一致或缓存命中率低的问题，进而影响系统性能。

#### 2. 学习成本
- **JPA 规范学习**：要熟练使用 Spring Data JPA，开发者需要了解 JPA 规范，包括实体映射、关系映射、查询语言等知识。对于初学者来说，学习这些知识需要花费一定的时间和精力。
- **复杂查询处理难度**：当遇到非常复杂的查询需求时，使用 Spring Data JPA 的自定义查询可能会变得复杂，需要开发者对 JPQL 或 SQL 有深入的理解，并且要熟悉 Spring Data JPA 的注解和方法使用。

#### 3. 灵活性受限
- **对数据库特性支持不足**：Spring Data JPA 主要基于 JPA 标准，对于一些特定数据库的高级特性（如特定的函数、存储过程等）支持可能不够完善。在需要使用这些特性时，开发者可能需要编写额外的代码或采用其他方式来实现。
- **难以控制 SQL 细节**：虽然可以使用 `@Query` 注解编写自定义查询，但在某些情况下，开发者仍然难以对生成的 SQL 语句进行精细的控制，无法满足一些对 SQL 执行细节有严格要求的场景。 


### MyBatis 优势
#### 1. SQL 控制灵活
- **直接编写 SQL**：MyBatis 允许开发者直接编写 SQL 语句，这对于复杂的查询、存储过程调用以及对 SQL 性能有严格要求的场景非常有利。开发者可以根据具体需求对 SQL 进行优化，以达到最佳的性能表现。例如，在处理涉及多表连接、复杂条件筛选的查询时，开发者能够手动编写高效的 SQL 语句。
- **动态 SQL 支持**：MyBatis 提供了强大的动态 SQL 功能，通过 `<if>`、`<choose>`、`<when>`、`<otherwise>`、`<where>`、`<set>`、`<foreach>` 等标签，可以根据不同的条件动态生成 SQL 语句。这使得 SQL 语句可以根据传入的参数灵活变化，提高了代码的复用性和灵活性。比如在一个查询方法中，根据用户传入的不同参数，动态决定是否添加某个查询条件。

#### 2. 学习成本低
- **简单易上手**：MyBatis 的配置和使用相对简单，它的核心就是 SQL 语句的编写和映射关系的配置。对于有一定 SQL 基础的开发者来说，很容易上手并快速应用到项目中。与一些复杂的 ORM 框架相比，MyBatis 的学习曲线较为平缓。
- **轻量级框架**：MyBatis 是一个轻量级的框架，不依赖于过多的第三方库，对系统资源的占用较少。它的设计理念简洁明了，主要专注于 SQL 与对象之间的映射，使得开发者能够更专注于业务逻辑和 SQL 优化。

#### 3. 易于与现有项目集成
- **与 Spring 集成良好**：MyBatis 可以很好地与 Spring 框架集成，借助 Spring 的依赖注入、事务管理等功能，进一步简化开发过程。在 Spring 项目中使用 MyBatis 时，可以方便地进行数据源配置、事务管理等操作，提高开发效率。
- **对现有数据库结构兼容性强**：MyBatis 对现有数据库结构的兼容性较好，不需要对数据库表结构进行大规模的修改或重构。它可以直接基于现有的数据库表进行映射配置，适合于对已有系统进行改造和维护的项目。

#### 4. 性能优化方便
- **可针对性优化 SQL**：由于开发者可以直接控制 SQL 语句，因此可以针对具体的业务场景和性能瓶颈进行有针对性的优化。例如，通过合理使用索引、优化查询语句结构、避免全表扫描等方式，提高数据库的查询性能。
- **一级缓存和二级缓存机制**：MyBatis 也提供了一级缓存（SqlSession 级别）和二级缓存（Mapper 级别）机制，可以在一定程度上减少数据库的访问次数，提高系统的性能。开发者可以根据实际需求选择是否开启缓存以及如何配置缓存策略。

### MyBatis 劣势
#### 1. 数据库移植性较差
- **SQL 依赖数据库特性**：由于开发者直接编写 SQL 语句，而不同的数据库在 SQL 语法和特性上存在一定的差异，因此当需要将项目从一个数据库迁移到另一个数据库时，可能需要对 SQL 语句进行大量的修改。例如，Oracle 和 MySQL 在日期函数、分页查询等方面的语法不同，迁移时需要调整相应的 SQL 语句。
#### 2. 代码维护成本较高
- **SQL 分散在多处**：在 MyBatis 项目中，SQL 语句通常分散在多个 XML 文件或注解中，当项目规模较大时，查找和维护这些 SQL 语句会变得比较困难。特别是当业务逻辑发生变化时，需要同时修改 Java 代码和对应的 SQL 语句，增加了代码的维护成本。
#### 3. 缺乏高级 ORM 功能
- **对象关系映射功能相对薄弱**：与一些全功能的 ORM 框架相比，MyBatis 的对象关系映射功能相对薄弱。例如，在处理复杂的对象关系（如继承、多态等）时，需要开发者手动编写更多的代码来实现，不够便捷和高效。
#### 4. 对开发人员要求较高
- **需要具备 SQL 技能**：MyBatis 的使用需要开发者具备一定的 SQL 技能，能够编写高效、正确的 SQL 语句。如果开发人员的 SQL 水平不高，可能会导致生成的 SQL 语句性能低下，影响系统的整体性能。 



### MyBatis 接受度高的方面及原因

#### 1. 复杂业务场景和性能要求高的项目

- **SQL 控制能力不足**：在一些复杂的业务场景中，可能需要编写非常复杂和高效的 SQL 语句来满足性能要求。JPA 虽然提供了 JPQL（Java Persistence Query Language）和本地 SQL 查询等方式，但在对 SQL 细节的控制上不如直接编写 SQL 灵活。例如，在处理一些涉及大量数据的复杂查询和报表生成时，开发者可能更倾向于使用 MyBatis 等可以直接编写和优化 SQL 的框架。
- **性能问题**：JPA 自动生成的 SQL 语句在某些情况下可能不够优化，尤其是在处理多表关联查询时，可能会产生过多的数据库交互和性能开销。对于一些对性能要求极高的项目，如高并发的互联网应用、实时数据处理系统等，JPA 可能无法满足性能需求。

#### 2. 已有技术栈和开发习惯的影响

- **已有框架的使用惯性**：国内很多开发团队已经在长期的项目开发中形成了自己的技术栈和开发习惯，例如使用 MyBatis 进行数据持久化。更换为 JPA 需要团队成员重新学习和适应新的框架，这可能会带来一定的学习成本和时间成本。而且，一些团队可能对现有的框架已经有了深入的了解和丰富的优化经验，不愿意轻易更换技术栈。 


## 针对某Java项目数据库SQL解耦的方案

考虑到某Java项目的现状及开发人员的意愿，以下是针对某Java项目数据库SQL解耦的方案。

### 方案1：MyBatis 多 XML 方案

1. 简单SQL：使用 MyBatis-Plus 框架提供的 Wrapper 以Java对象的方式构建查询条件。
2. 复杂SQL：针对不同的数据库，对应写一套复杂 SQL 的 XML。例如未来有客户用到了 Oracle，则需要针对性的写一套关于 Oracle 的 XML；客户如果用到了 MySQL，则需要针对性的写一套关于 MySQL 的 XML。


特点：

1. 不变应万变。
2. 有新客户需求，再说。

问题：

1. 非真正意义上的解耦。客户的环境不可预知，多一套数据库环境，多写一套XML
2. 增加开发工作量、测试工作量。工作量曲线短期可能会比较平缓，长期会陡峭。

### 方案2：MyBatis + Doris 方案

1. 简单SQL：使用 MyBatis-Plus 框架提供的 Wrapper 以Java对象的方式构建查询条件。
2. 复杂查SQL从工作台剥离，前置到集成平台来做。尽量确保某Java项目所使用的表就是简单表。
3. 无法剥离的复杂查SQL或者性能要求高的SQL使用 Doris 来做。
4. 部分业务场景（比如需要关联 data、md、scp 查询），数据库、 Doris 需要做同步。同步可以是一个事务操作同步更新多个数据源，也可以让 ETL 重新集成。

特点：

1. 数据库完全解耦。
2. 性能可控。


问题：

1. 业务流程的重塑，BA是否接受整改？
2. 与 Doris 耦合。


## 参考引用

* 原文同步至：<https://waylau.com/decoupling-java-projects-from-databases/>
* 《Spring Boot 企业级应用开发实战》（北京大学出版社）：<https://github.com/waylau/spring-boot-enterprise-application-development>